# 화면을 개발하기 위한 필수 단위 인스턴스 & 컴포넌트

구조적으로 UI를 설계하기 위해서는 왜 컴포넌트가 필요하고, 화면을 그리기 위해서는 왜 인스턴스가 있어야 하는지 알아보겠습니다.

# 뷰 인스턴스

### 1. 뷰 인스턴스의 정의와 속성

뷰 인스턴스(Instance)는 뷰로 화면을 개발하기 위해 필수적으로 생성해야 하는 **_기본 단위_** 입니다.

1. 뷰 인스턴스 생성
   뷰 인스턴스를 사용하기 위해서는

   ```
       new Vue({
           ...
       });
   ```

   와 같은 형식으로 뷰 인스턴스를 생성해야 합니다.

2. 뷰 인스턴스 생성자
   new Vue()로 인스턴스를 생성할 때 Vue를 생성자라고 합니다.  
   Vue 생성자는 뷰 라이브러리를 로딩하고 나는 접근할 수 있습니다. 생성자를 사용하는 이유는 뷰로 개발할 때 필요한 기능들을 생성자에 미리 정의해 놓고 사용자가 그 기능을 재정의하여 편리하게 사용하도록 하기 위해서입니다.

3. 뷰 인스턴스 옵션 속성
   뷰 인스턴스 옵션 속성은 인스턴스를 생성할 때 재정의할 data, el, template 등의 속성을 의미합니다.

4. 뷰 인스턴스의 유효 범위

   - 인스턴스의 유효 범위란?
     뷰 인스턴스를 생성하면 HTML의 특정 범위 안에서만 옵션 속성들이 적용되어 나타납니다.  
     이를 인스턴스의 유효 범위라고 합니다. **_지역 컴포넌트와 전역 컴포넌트의 차이점을 이해하기 위해서 꼭 아라야 하는 개념이며, 인스턴스의 유효 범위는 el 속성과 밀접한 관계가 있습니다._**

     인스턴스의 유효 범위를 이해하려면 인스턴스가 생성된 후 화면에 어떻게 적용되는지 알아야 합니다.

     - new Vue()로 인스턴스 생성 후 화면에 인스턴스 옵션 속성을 적용하는 과정
       1. 뷰 라이브러리 파일 로딩
       2. 인스턴스 객체 생성(옵션 속성 포함)
       3. 특정 화면 요소에 인스턴스를 붙임
       4. 인스턴스 내용이 화면 요소로 변환
       5. 변환된 화면 요소를 사용자가 최종 확인

   기존 2장에서 만든 index.html의 뷰 인스턴스의 유효범위는 el에 해당하는 \<div id="app"> 태그 아래에 오는 요소들로 제한됩니다.

5. 뷰 인스턴스 라이프 사이클
   인스턴스의 상태에 따라 호출할 수 있는 속성들을 라이프 사이클(life cycle) 속성이라고 하고 각 라이프 사이클 속성에서 실행되는 커스텀 로직을 라이프 사이클 훅(hook)이라고 합니다.

   - 라이프 사이클

     1. **인스턴스 생성**
        - 이벤트 및 라이프 사이클 초기화
          - beforeCreate
        - 화면에 반응성 주입
          - created
        - el, template 속성 확인
        - template 속성 내용을 render()로 변환
          - beforeMount
        - $el 생성 후 el 속성 값을 대입
          - mounted
     2. **인스턴스를 화면에 부착**  
        데이터가 변경되는 경우에만 거침
        - 인스턴스의 데이터 변경
          - beforeUpdate
        - 화면 재 렌더링 및 데이터 갱신
          - updated
     3. **인스턴스 내용 갱신**
        - 인스턴스 접근 가능
          - beforeDestroy
        - 컴포넌트, 인스턴스, 디렉티브 등 모두 해제
          - destroyed
     4. **인스턴스 소멸**

6. 뷰 인스턴스 라이프 사이클 디테일

   - beforeCreate  
     인스턴스가 생성되고 나서 가장 처음으로 실행되는 라이프 사이클 단계입니다.  
      이 단계에서는 data 속성과 methods 속성이 아직 인스턴스에 정의되어 있지 않고, 돔과 같은 화면 요소에도 접근할 수 없습니다.
   - created  
     beforeCreate 라이프 사이클 단계 다음에 실행되는 단계입니다. data 속성과 methods 속성이 정의되었기 때문에 this.data 또는 this.fetchData()와 같은 로직들을 이용하여 data 속성과 methods 속성에 정의된 값에 접근하여 로직을 실행할 수 있습니다. 다만, 아직 인스턴스가 화면 요소에 부탁되기 전이기 때문에 template 속성에 정의된 돔 요소로 접근할 수 없습니다.

     그리고 **_data 속성과 methods 속성에 접근할 수 있는 가장 첫 라이프 사이클 단계이자 컴포넌트가 생성되고 나서 실행되는 단계_** 이기 때문에 **_서버에 데이터를 요청하여 받아오는 로직을 수행하기도 좋습니다._**

   - beforeMount  
     created 단계 이후 template 속성에 지정한 마크업 속성을 render() 함수로 변환한 후 el 속성에 지정한 화면 요소(돔)에 인스턴스를 부착하기 전에 호출되는 단계입니다. render() 함수가 호출되기 직전의 로직을 추가하기 좋습니다.

   - mounted  
      el 속성에서 지정한 화면 요소에 인스턴스가 부착되고 나면 호출되는 단계로, **_template 속성에 정의한 화면 요소(돔)에 접근할 수 있어 화면 요소를 제어하는 로직을 수행하기 좋은 단계입니다._**  
      다만, 돔에 인스턴스가 부착되자마자 바로 호출되기 때문에 하위 컴포넌트나 외부 라이브러리에 의해 추가된 화면 요소들이 최종 HTML 코드로 변환되는 시점과 다를 수 있습니다.

   - beforeUpdate  
     관찰하고 있는 데이터가 변경되면 가상 돔으로 **_화면을 다시 그리기 전에 호출되는 단계이며, 변경 예정인 새 데이터에 접근할 수 있어 변경 예정 데이터의 값과 관련된 로직을 미리 넣을 수 있습니다._**

   - updated  
     데이터가 변경되고 나서 가상 돔으로 다시 화면을 그리고나면 실행되는 단계입니다.  
     **_데이터 변경으로 인한 화면 요소 변경까지 완료된 시점이므로, 데이터 변경 후 화면 요소 제어와 관련된 로직을 추가하기 좋은 단계입니다._** 이 단계에서 데이터 값을 변경하면 무한 루프에 빠질 수 있기 때문에 값을 변경하려면 computed, watch와 같은 속성을 사용해야 합니다.

   - beforeDestory
     뷰 인스턴스가 파괴되기 직전에 호출되는 단계입니다. 이 단계에서는 아직 인스턴스에 접근할 수 있습니다. 따라서 뷰 인스턴스의 데이터를 삭제하기 좋은 단계입니다.

   - destroyed
     뷰 인스턴스가 파괴되고 나서 호출되는 단계입니다. 뷰 인스턴스에 정의한 모든 속성이 제거되고 하위에 선언한 인스턴스들 또한 모두 파괴됩니다.

# 뷰 컴포넌트

### 1. 컴포넌트란?

컴포넌트(Component)란 조합하여 화면을 구성할 수 있는 블록(화면의 특정 영역)을 의미합니다.  
컴포넌트를 활용하면 화면을 빠르게 구조화하여 일괄적인 패턴으로 개발할 수 있습니다.
이렇게 화면의 영역을 컴포넌트로 쪼개서 재활용할 수 있는 형태로 관리하면 나중에 코드를 다시 사용하기가 훨씬 편리합니다. 또한 모든 사람들이 정해진 방식대로 컴포넌트를 등록하거나 사용하게 되므로 남이 작성한 코드를 직관적으로 이해할 수 있습니다.

### 2. 컴포넌트 등록하기

컴포넌트를 등록하는 방법은 전역과 지역의 두 가지가 있습니다.  
지역(Local) 컴포넌트는 특정 인스턴스에서만 유효한 범위를 갖고, 전역(Global) 컴포넌트는 여러 인스턴스에서 공통으로 사용할 수 있습니다.

1. 전역 컴포넌트 등록

```
Vue.component('컴포넌트 이름', {
  //컴포넌트 내용
})

//Vue 생성자에서 .component()를 호출
//컴포넌트 이름 : template 속성에서 사용할 HTML 사용자 정의 태그 이름을 의미
```

전역 컴포넌트는 인스턴스를 새로 생성할 때마다 인스턴스에 components 속성으로 등록할 필요 없이 한 번 등록하면 어느 인스턴스에서든지 사용할 수 있습니다.

2. 지역 컴포넌트 등록

```
new Vue({
  components: {
    '컴포넌트 이름': 컴포넌트 내용
  }
})
```

지역 컴포넌트는 새 인스턴스를 생성할 때마다 등록해 줘야 합니다.

# 뷰 컴포넌트 통신

### 1. 컴포넌트 간 통신과 유효범위

뷰(vue.js)는 컴포넌트로 화면을 구성하므로 같은 웹 페이지라도 데이터를 공유할 수 업습니다. 그 이유는 컴포넌트마다 자체적으로 고유한 유효 범위(Scope)를 갖기 때문입니다.  
이는 뷰 프레임워크 내부적으로 정의된 특징입니다. 따라서 각 컴포넌트의 유효 범위가 독립적이기 때문에 다른 컴포넌트의 값을 직접적으로 참조할 수가 없습니다.

### 2. 상, 하위 컴포넌트 관계

뷰 프레임워크 자체에서 정의한 컴포넌트 데이터 전달 방법을 따라야 하는데, 가장 기본적인 데이터 전달 방법은 바로 상위(부모) - 하위(자식) 컴포넌트 간의 데이터 전달 방법입니다.

상위 컴포넌트에서 하위 컴포넌트로 props라는 특별한 속성을 전달합니다.  
하위에서 상위로는 기본적으로 이벤트만 전달할 수 있습니다.

### 3. 상위에서 하위 컴포넌트로 데이터 전달하기

1. props 속성
   props는 상위 컴포넌트에서 하위 컴포넌트로 데이터를 전달할 때 사용하는 속성입니다.
   props 속성을 사용하려면 하위 컴포넌트의 속성에 정의합니다.

   ```
   Vue.component('child-component', {
     props: ['props 속성 이름']
   });
   ```

   그런 다음 상위 컴포넌트의 HTML 코드에 등록된 child-component 컴포넌트 태그에 v-bind 속성을 추가합니다.

   ```
    <child-component v-bind:props 속성 이름="상위 컴포넌트의 data 속성"></child-component>
   ```

### 4. 하위에서 상위 컴포넌트로 이벤트 전달하기

1. 이벤트 발생과 수신
   이벤트를 발생시켜(event emit) 상위 컴포넌트에 신호를 보내서 하위에서 상위 컴포넌트로 통신을 합니다. 상위 컴포넌트에서 하위 컴포넌트의 특정 이벤트가 발생하기를 기다리고 있다가 하위 컴포넌트에서 특정 이벤트가 발생하면 상위 컴포넌트에서 해당 이벤트를 수신하여 상위 컴포넌트의 메서드를 호출하는 것입니다.

2. 이벤트 발생과 수신 형식
   $emit()과 v-on: 속성을 사용하여 구현합니다.

   ```
   //이벤트 발생
   this.$emit('이벤트명');

   //이벤트 수신
   <child-component v-on:이벤트명="상위 컴포넌트의 메서드명"></child-component>
   ```

   $emit()을 호출하면 괄호 안에 정의된 이벤트가 발생합니다. 그리고 일반적으로 $emit()을 호출하는 위치는 하위 컴포넌트의 특정 메서드 내부입니다. 따라서 $emit()을 호출할때 사용하는 this는 하위 컴포넌트를 가리킵니다.

### 5. 같은 레벨의 컴포넌트 간 통신

상위에서 하위로 props를 전달하고, 하위에서 상위로 이벤트를 전달하여 통신하는 법은 배웠지만 이번에는 상위 - 하위 관계가 아니라 같은 레벨에 있는 컴포넌트끼리 어떻게 통신하는지 알아보겠습니다.

1. 관계 없는 컴포넌트 간 통신 - 이벤트 버스
   이벤트 버스(Event Bus)는 개발자가 지정한 2개의 컴포넌트 간에 데이터를 주고받을 수 있는 방법입니다.

2. 이벤트 버스 형식

   ```
   //이벤트 버스를 위한 추가 인스턴스 1개 생성
    var evnetBus = new Vue();

    //이벤트를 보내는 컴포넌트
    methods: {
      메서드명: function() {
        eventBus.$emit('이벤트명', 데이터);
      }
    }

    //이벤트를 받는 컴포넌트
    methods: {
      created: function() {
        eventBus.$on('이벤트명', function(데이터){

        });
      }
    }
   ```

3. 이벤트 버스 장단점
   **_이벤트 버스를 활용하면 props 속성을 이용하지 않고도 원하는 컴포넌트 간에 직접적으로 데이터를 전달할 수 있어 편리(장점)_**  
   **_컴포넌트가 많아지면 어디서 어디로 보냈는지 관리가 되지 않는 문제가 발생합니다.(단점)_**  
   이 문제를 해결하려면 **_뷰엑스(Vuex)_** 라는 상태 관리 도구가 필요합니다.

   - 뷰엑스는 중, 대형 애플리케이션에서 컴포넌트 간의 데이터 관리를 효율적으로 하는 라이브러리입니다. 구글에서 'vuex 시작하기', 'vuex 튜토리얼'로 검색해 보세요.
